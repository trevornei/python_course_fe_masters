Lists have order 
Set are unordered.

List Comprehensions:
Start with what you are iterating over. [for name in names  ]
1. Then you can add a condition to the far left. [for name in names if name.startswith("A")]
2. Then you can add a transformation. [for name in names if name.startswith("A") print(name)]

10/16/24

Review: 
List comprehensions are a powerful tool because of their shortened syntax, you can make iterative loops, and the logic is easy to read.

Four different types of data types:
- Lists [] ordered
- Sets {1, 2, 3} unordered
- Tuples () 
- Dictionaries {} key value pairs, sytax: uses colons "key: value:"

Generators are efficient as your data structures grow...
- They are memory efficient because the don't create items all at once in memory.
    - They don't generate useless data.
    - Iterating over generators is faster than iterating over lists.

Slicing is a way to create sublists from LARGER lists.

Can combine two lists with the zip(list_one, list_two) function

Everything in python is an object!

OOP and Classes:
Classes are types of something.
Instance is and instance OF something. 

type(int(5))
>>> <class 'int'>

type(int)
>>> <class 'type'>

__specialmethods__
--> Learned about: constructor method and string representation.

Next up... Tomorrow I will learn about inheritance.
Inheritance allows a subclass to inherit:
- Properties
||
- methods 
|
 \
  \
    â€“ > from the parent class.

    Parent class = super class
    Child Class = subclass
   # Parent class
class Vehicle:
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year

    def start(self):
        print(f"{self.make} {self.model} is starting.")

# Child class inheriting from Vehicle
class Car(Vehicle):
    def __init__(self, make, model, year, doors):
        # Call the parent class's constructor using 'super()'
        super().__init__(make, model, year)
        self.doors = doors

    # New method specific to the Car class
    def lock_doors(self):
        print(f"Locking {self.doors} doors.")

# Child class inheriting from Vehicle
class Motorcycle(Vehicle):
    def __init__(self, make, model, year, helmet):
        super().__init__(make, model, year)
        self.helmet = helmet

    # Override the start method for Motorcycle
    def start(self):
        print(f"{self.make} {self.model} motorcycle is roaring to life.")

# Creating instances of Car and Motorcycle
car = Car("Toyota", "Camry", 2020, 4)
motorcycle = Motorcycle("Harley-Davidson", "Sportster", 2019, True)

# Using inherited and new methods
car.start()  # Inherited from Vehicle
car.lock_doors()  # New method in Car

motorcycle.start()  # Overridden method in Motorcycle

Output: 
Toyota Camry is starting.
Locking 4 doors.
Harley-Davidson Sportster motorcycle is roaring to life.


Both the car and motorcylce are subclasses of the vehicle parent class.
super() allows the subclass to get properties from the super class.

Both the car and motorcycle instances have their own unique methods. 